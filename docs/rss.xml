<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Eureka!!</title><link>https://pyae123zd.github.io</link><description>人类的悲欢并不相通，我只觉得他们吵闹。</description><copyright>Eureka!!</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://raw.githubusercontent.com/pyae123zd/PicoRepo/main/img/Pasted%20Image%2020230803150435.png</url><title>avatar</title><link>https://pyae123zd.github.io</link></image><lastBuildDate>Wed, 24 Jan 2024 03:14:02 +0000</lastBuildDate><managingEditor>Eureka!!</managingEditor><pubDate>Wed, 24 Jan 2024 03:14:02 +0000</pubDate><ttl>60</ttl><webMaster>Eureka!!</webMaster><item><title>AI代码工具</title><link>https://pyae123zd.github.io/post/AI-dai-ma-gong-ju.html</link><description>---&#13;
date created: 2024-01-11&#13;
&#13;
---&#13;
&#13;
### 可选工具&#13;
&#13;
- [[Copilot](https://github.com/features/copilot)](https://github.com/features/copilot) &#13;
  - $10 per month,$100 per year&#13;
- [[Codeium](https://codeium.com/)](https://codeium.com/)&#13;
  - free&#13;
- CodeGeeX(清华)&#13;
  - free&#13;
  - 直连&#13;
  - 可自定义训练&#13;
- 通义灵码(阿里)&#13;
  - free&#13;
  - 直连&#13;
- Tabline&#13;
- Replit&#13;
- ...&#13;
&#13;
---&#13;
&#13;
### 功能&#13;
&#13;
- 生成代码&#13;
- 解释代码&#13;
- 优化代码&#13;
- 生成测试方法&#13;
- 生成注释&#13;
- 修复问题代码&#13;
&#13;
### 代码生成工具使用&#13;
&#13;
- 简单场景：&#13;
  - 联系上下文直接补全&#13;
- 有固定实现的功能：&#13;
  - 注释描述（最好是英文）&#13;
  - 直接使用方法名来提示&#13;
- 复杂场景&#13;
  - 注释描述&#13;
  - 拆分任务&#13;
&#13;
## 效果对比&#13;
&#13;
### 案例一：使用Java 写一个工具类 根据某个实体类的字段名 实现word中模版内容的填充&#13;
&#13;
- Github Copilot&#13;
&#13;
```java&#13;
import org.apache.poi.xwpf.usermodel.*;&#13;
&#13;
import java.io.File;&#13;
import java.io.FileInputStream;&#13;
import java.io.FileOutputStream;&#13;
import java.lang.reflect.Field;&#13;
&#13;
public class WordFiller {&#13;
    public static void fillTemplate(Object entity, String templatePath, String outputPath) throws Exception {&#13;
        XWPFDocument doc = new XWPFDocument(new FileInputStream(new File(templatePath)));&#13;
        for (Field field : entity.getClass().getDeclaredFields()) {&#13;
            field.setAccessible(true);&#13;
            String name = field.getName();&#13;
            Object value = field.get(entity);&#13;
            for (XWPFParagraph p : doc.getParagraphs()) {&#13;
                for (XWPFRun r : p.getRuns()) {&#13;
                    String text = r.getText(0);&#13;
                    if (text != null &amp;&amp; text.contains("{" + name + "}")) {&#13;
                        text = text.replace("{" + name + "}", value.toString());&#13;
                        r.setText(text, 0);&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        FileOutputStream out = new FileOutputStream(outputPath);&#13;
        doc.write(out);&#13;
        out.close();&#13;
    }&#13;
}&#13;
```&#13;
&#13;
- Codeium&#13;
&#13;
```java&#13;
import java.util.Map;&#13;
&#13;
public class WordTemplateUtil {&#13;
    public static String fillTemplate(String template, Map&lt;String, String&gt; fieldMap) {&#13;
        for (Map.Entry&lt;String, String&gt; entry : fieldMap.entrySet()) {&#13;
            String fieldName = entry.getKey();&#13;
            String value = entry.getValue();&#13;
            template = template.replace("{{" + fieldName + "}}", value);&#13;
        }&#13;
        return template;&#13;
    }&#13;
}&#13;
```&#13;
&#13;
提示输入为实体类后&#13;
&#13;
```java&#13;
import java.lang.reflect.Field;&#13;
import java.util.Map;&#13;
&#13;
public class WordTemplateUtil {&#13;
    public static String fillTemplateFromEntity(String template, YourEntityClass entity) throws IllegalAccessException {&#13;
        Class&lt;?&gt; entityClass = entity.getClass();&#13;
        Field[] fields = entityClass.getDeclaredFields();&#13;
        for (Field field : fields) {&#13;
            field.setAccessible(true);&#13;
            String fieldName = field.getName();&#13;
            String value = field.get(entity).toString();&#13;
            template = template.replace("{{" + fieldName + "}}", value);&#13;
        }&#13;
        return template;&#13;
    }&#13;
}&#13;
```&#13;
&#13;
- 通义灵码&#13;
&#13;
```java&#13;
import org.apache.poi.xwpf.usermodel.*;&#13;
import java.io.File;&#13;
import java.io.FileInputStream;&#13;
import java.io.FileOutputStream;&#13;
import java.lang.reflect.Field;&#13;
import java.util.List;&#13;
&#13;
public class WordTemplateFiller {&#13;
&#13;
    public static void fillTemplate(MyEntity entity, String templatePath, String outputPath) throws Exception {&#13;
        // 读取Word模板文件&#13;
        FileInputStream fis = new FileInputStream(templatePath);&#13;
        XWPFDocument document = new XWPFDocument(fis);&#13;
&#13;
        // 遍历实体类的所有字段&#13;
        Field[] fields = MyEntity.class.getDeclaredFields();&#13;
        for (Field field : fields) {&#13;
            // 设置访问权限为可访问&#13;
            field.setAccessible(true);&#13;
&#13;
            // 获取字段名&#13;
            String fieldName = field.getName();&#13;
&#13;
            // 在Word文档中查找与字段名匹配的占位符（例如 {{fieldName}}）&#13;
            List&lt;XWPFParagraph&gt; paragraphs = document.getParagraphs();&#13;
            for (XWPFParagraph paragraph : paragraphs) {&#13;
                List&lt;XWPFRun&gt; runs = paragraph.getRuns();&#13;
                for (XWPFRun run : runs) {&#13;
                    String text = run.getText(0);&#13;
                    if (text != null &amp;&amp; text.contains("{{" + fieldName + "}}")) {&#13;
                        // 替换占位符为字段的实际值&#13;
                        Object fieldValue = field.get(entity);&#13;
                        String newValue = fieldValue != null ? fieldValue.toString() : "";&#13;
                        run.setText(newValue, 0);&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        // 写入填充后的内容到新的Word文件&#13;
        FileOutputStream out = new FileOutputStream(outputPath);&#13;
        document.write(out);&#13;
        out.close();&#13;
        document.close();&#13;
        fis.close();&#13;
    }&#13;
}&#13;
&#13;
// 假设的实体类&#13;
class MyEntity {&#13;
    private String name;&#13;
    private String address;&#13;
    // 其他字段及对应的getter/setter...&#13;
}&#13;
&#13;
```&#13;
&#13;
- CodeGeeX&#13;
&#13;
```python&#13;
from docx import Document&#13;
&#13;
class EntityClass:&#13;
    def __init__(self, field1, field2, field3):&#13;
        self.field1 = field1&#13;
        self.field2 = field2&#13;
        self.field3 = field3&#13;
&#13;
def fill_template(entity, template_path):&#13;
    # 创建一个新的Word文档&#13;
    doc = Document()&#13;
&#13;
    # 打开模板文件&#13;
    with open(template_path, 'rb') as file:&#13;
        # 将模板内容添加到新的Word文档中&#13;
        doc.add_paragraph(file.read().decode('utf-8'))&#13;
&#13;
    # 根据实体类的字段名进行模板内容的填充&#13;
    for paragraph in doc.paragraphs:&#13;
        for run in paragraph.runs:&#13;
            for key, value in entity.__dict__.items():&#13;
                text = f'{{{key}}}'&#13;
                if text in run.text:&#13;
                    run.text = run.text.replace(text, str(value))&#13;
&#13;
    return doc&#13;
&#13;
# 示例&#13;
entity = EntityClass('John Doe', 'Software Engineer', 30)&#13;
template_path = 'template.docx'&#13;
doc = fill_template(entity, template_path)&#13;
doc.save('output.docx')&#13;
&#13;
```&#13;
&#13;
生成了python代码&#13;
&#13;
- ChatGpt&#13;
&#13;
```java&#13;
import java.io.FileInputStream;&#13;
import java.io.FileOutputStream;&#13;
import java.io.IOException;&#13;
import java.util.Map;&#13;
&#13;
import org.apache.poi.xwpf.usermodel.XWPFDocument;&#13;
import org.apache.poi.xwpf.usermodel.XWPFPicture;&#13;
import org.apache.poi.xwpf.usermodel.XWPFRun;&#13;
import org.apache.poi.xwpf.usermodel.XWPFSimpleShape;&#13;
import org.apache.poi.xwpf.usermodel.XWPFTable;&#13;
import org.apache.poi.xwpf.usermodel.XWPFTableRow;&#13;
&#13;
public class WordTemplateFiller {&#13;
&#13;
    public static void fillTemplate(String templatePath, String outputPath, Map&lt;String, String&gt; fieldValues) {&#13;
        try (FileInputStream fis = new FileInputStream(templatePath);&#13;
             XWPFDocument document = new XWPFDocument(fis)) {&#13;
&#13;
            // 替换文本内容&#13;
            for (XWPFParagraph paragraph : document.getParagraphs()) {&#13;
                for (XWPFRun run : paragraph.getRuns()) {&#13;
                    String text = run.getText(0);&#13;
                    if (text != null) {&#13;
                        for (Map.Entry&lt;String, String&gt; entry : fieldValues.entrySet()) {&#13;
                            text = text.replace("${" + entry.getKey() + "}", entry.getValue());&#13;
                        }&#13;
                        run.setText(text, 0);&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            // 替换表格内容&#13;
            for (XWPFTable table : document.getTables()) {&#13;
                for (XWPFTableRow row : table.getRows()) {&#13;
                    for (XWPFRun run : row.getTableCells().get(0).getParagraphs().get(0).getRuns()) {&#13;
                        String text = run.getText(0);&#13;
                        if (text != null) {&#13;
                            for (Map.Entry&lt;String, String&gt; entry : fieldValues.entrySet()) {&#13;
                                text = text.replace("${" + entry.getKey() + "}", entry.getValue());&#13;
                            }&#13;
                            run.setText(text, 0);&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            try (FileOutputStream fos = new FileOutputStream(outputPath)) {&#13;
                document.write(fos);&#13;
            }&#13;
&#13;
        } catch (IOException e) {&#13;
            e.printStackTrace();&#13;
        }&#13;
    }&#13;
&#13;
    public static void main(String[] args) {&#13;
        // 示例用法&#13;
        String templatePath = "path/to/your/template.docx";&#13;
        String outputPath = "path/to/your/output.docx";&#13;
&#13;
        // 字段名和对应的值&#13;
        Map&lt;String, String&gt; fieldValues = Map.of(&#13;
                "FieldName1", "Value1",&#13;
                "FieldName2", "Value2",&#13;
                // 添加更多字段&#13;
        );&#13;
&#13;
        fillTemplate(templatePath, outputPath, fieldValues);&#13;
    }&#13;
}&#13;
&#13;
```&#13;
&#13;
### 案例二：使用Java写个从prometheus中获取当前CPU占用率TOP5的主机的方法&#13;
&#13;
- Github Copilot&#13;
  ![Pasted image 20240124103118](https://raw.githubusercontent.com/pyae123zd/PicoRepo/main/img/Pasted%20image%2020240124103118.png)&#13;
&#13;
&gt; `100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)`：这个查询关注的是每个实例的CPU使用率。</description><guid isPermaLink="true">https://pyae123zd.github.io/post/AI-dai-ma-gong-ju.html</guid><pubDate>Wed, 24 Jan 2024 03:02:08 +0000</pubDate></item><item><title>Guns3开发规范</title><link>https://pyae123zd.github.io/post/Guns3-kai-fa-gui-fan.html</link><description>2024-01-03&#13;
&#13;
### 1. 强依赖关系&#13;
&#13;
项目基于spring boot架构，所以对spring boot强依赖，另外对hutool工具类，lombok，fastjson强依赖，其他框架不强依赖&#13;
&#13;
### 2. 任何类均可拓展&#13;
&#13;
利用@Primary注解来替换已经装载的spring容器中的bean&#13;
&#13;
### 3.每个模块要有一个常量类&#13;
&#13;
常量类用来存放模块名称和异常枚举的步进值，如果本模块异常较多，可以存放多个步进值&#13;
&#13;
```java&#13;
public interface RuleConstants {&#13;
&#13;
    /**&#13;
     * 规则模块的名称&#13;
     */&#13;
    String RULE_MODULE_NAME = "kernel-a-rule";&#13;
&#13;
    /**&#13;
     * 异常枚举的步进值&#13;
     */&#13;
    String RULE_EXCEPTION_STEP_CODE = "00";&#13;
&#13;
}&#13;
```&#13;
&#13;
### 4. 每个模块要有一个异常类&#13;
&#13;
异常类要继承ServiceException&#13;
&#13;
```java&#13;
public class DaoException extends ServiceException {&#13;
&#13;
    public DaoException(AbstractExceptionEnum exception) {&#13;
        super(DbConstants.DB_MODULE_NAME, exception);&#13;
    }&#13;
&#13;
}&#13;
```&#13;
&#13;
### 5. expander包是对配置表的拓展&#13;
&#13;
kernel-d-config模块只负责对系统配置的初始化，新增，删除等操作，不进行对某个具体配置的维护，各个模块需要配置拓展属性时，在各个模块的api模块建立expander包维护&#13;
&#13;
### 6. Bean的装配，尽量在类的构造函数，不要在类的内部用@Resource或者@Autowired&#13;
&#13;
构造函数装配更灵活，如果直接用@Resource则会交给spring去装配，spring会去找到容器中的相关bean，不如手动的灵活&#13;
&#13;
多出现在装配的是接口的情况，如果接口有多个实现，很明显用构造函数去装配更合适&#13;
&#13;
### 7. pojo的分包结构&#13;
&#13;
pojo下可以分为request（控制器层请求参数的封装），response（控制器层响应参数的封装），param（其他类下参数的封装）&#13;
&#13;
其中request包下的类以Request结尾，response包下的类以Response结尾，param包下的类以Param结尾&#13;
&#13;
request包下的类一般会加上参数校验注解，参数校验用的hibernate validator注解&#13;
&#13;
一般情况，直接用实体返回，减少一些pojo的书写，复杂的返回对象还是要单独封装pojo&#13;
&#13;
### 8. pom中的注释要写清楚，为什么引用这个模块写到每个依赖上边&#13;
&#13;
例如，如下写法：&#13;
&#13;
```xml&#13;
&lt;!--jwt模块--&gt;&#13;
&lt;!--用来给生成带鉴权的url用--&gt;&#13;
&lt;dependency&gt;&#13;
    &lt;groupId&gt;com.sedinbj.kernel&lt;/groupId&gt;&#13;
    &lt;artifactId&gt;jwt-sdk&lt;/artifactId&gt;&#13;
    &lt;version&gt;1.0.0&lt;/version&gt;&#13;
&lt;/dependency&gt;&#13;
```&#13;
&#13;
### 9. @ApiResource 上的 path url 写完整的请求url 不要写到类上url&#13;
&#13;
以下是错误示例&#13;
&#13;
```java&#13;
@RestController&#13;
@ApiResource(name = "配置管理", path = "/system/config/")&#13;
public class SysConfigController {&#13;
&#13;
    @GetResource(name = "获取配置列表", path = "/list")&#13;
    public ResponseData pageList() {&#13;
        return new SuccessResponseData();&#13;
    }&#13;
    &#13;
}&#13;
```&#13;
&#13;
### 10. private方法要放到方法最下边&#13;
&#13;
在类中 private 方法放到最下边&#13;
&#13;
```java&#13;
public class ConfigServiceImpl implements ConfigService {&#13;
&#13;
    public List&lt;Long&gt; getList() {&#13;
        return null;&#13;
    }&#13;
&#13;
    public Object getDeatil() {&#13;
        return null;&#13;
    }&#13;
&#13;
    private Object getOne() {&#13;
        return null;&#13;
    }&#13;
&#13;
}&#13;
```&#13;
&#13;
### 11. Controller 中 post get 规范&#13;
&#13;
在 Controller 类中所有不涉及到数据变动的接口，例如分页查询、根据主键获取详情等查询接口使用 @GetResource 注解，其余添加、修改、删除接口统一使用 @PostResource 注解 例如&#13;
&#13;
```java&#13;
&#13;
@RestController&#13;
@ApiResource(name = "配置管理", path = "/system/config/")&#13;
public class SysConfigController {&#13;
&#13;
    @GetResource(name = "获取配置列表", path = "/list")&#13;
    public ResponseData pageList() {&#13;
        return new SuccessResponseData();&#13;
    }&#13;
&#13;
    @PostResource(name = "添加配置", path = "/add")&#13;
    public ResponseData add() {&#13;
        return new SuccessResponseData();&#13;
    }&#13;
&#13;
    @PostResource(name = "修改配置", path = "/update")&#13;
    public ResponseData update() {&#13;
        return new SuccessResponseData();&#13;
    }&#13;
&#13;
    @PostResource(name = "删除配置", path = "/delete")&#13;
    public ResponseData delete() {&#13;
        return new SuccessResponseData();&#13;
    }&#13;
&#13;
}&#13;
```&#13;
&#13;
### 12. api，枚举，异常等类创建后就尽快提交&#13;
&#13;
创建好后直接提交，为了方便别人用，不用别人再创建，防止重复，在创建之前，先拉取一下代码看看别人是否创建了&#13;
&#13;
### 13. 请求参数要加@ChineseDescription注解&#13;
&#13;
&#13;
### 14. 请求参数类要继承BaseRequest，实体类继承BaseEntity，Controller方法响应结果统一使用SuccessResponseData封装，若有错误需抛出有实际错误信息的异常&#13;
&#13;
&#13;
### 15. service层方法的顺序，先写增改删操作，最后写查询操作&#13;
&#13;
service接口和service实现的顺序要一致&#13;
&#13;
```java&#13;
@GetResource(name = "查看详情", path = "/company/detail", responseClass = CompanyResponse.class)&#13;
```&#13;
&#13;
### 16. 为了方便加业务缓存，所有的dao操作不要直接用xxxMapper&#13;
&#13;
统一放在service操作dao，别的层不能直接调用xxxMapper类中的方法。</description><guid isPermaLink="true">https://pyae123zd.github.io/post/Guns3-kai-fa-gui-fan.html</guid><pubDate>Wed, 03 Jan 2024 09:11:12 +0000</pubDate></item><item><title>鲁迅的名言名句</title><link>https://pyae123zd.github.io/post/lu-xun-de-ming-yan-ming-ju.html</link><description>&#13;
# 鲁迅&#13;
[![](https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/%E9%B2%81%E8%BF%85lx.jpg/220px-%E9%B2%81%E8%BF%85lx.jpg)](https://zh.wikiquote.org/wiki/File:%E9%B2%81%E8%BF%85lx.jpg)&#13;
&#13;
我想：希望本是无所谓有，无所谓无的。</description><guid isPermaLink="true">https://pyae123zd.github.io/post/lu-xun-de-ming-yan-ming-ju.html</guid><pubDate>Mon, 11 Dec 2023 02:53:59 +0000</pubDate></item><item><title>骚气编程技巧</title><link>https://pyae123zd.github.io/post/sao-qi-bian-cheng-ji-qiao.html</link><description>&#13;
## 工具类&#13;
&#13;
- hutool&#13;
- apache-commons&#13;
- google-guava&#13;
&#13;
## 函数式编程&#13;
- [Vavr](https://docs.vavr.io/)&#13;
	- ![Pasted image 20230809191221](https://raw.githubusercontent.com/pyae123zd/PicoRepo/main/img/Pasted%20image%2020230809191221.png)&#13;
	- ![Pasted image 20230809183348](https://raw.githubusercontent.com/pyae123zd/PicoRepo/main/img/Pasted%20image%2020230809183348.png)&#13;
## 增强流处理&#13;
- [StreamEx](https://www.baeldung.com/streamex)&#13;
&#13;
## 防御式编程&#13;
- Optional&#13;
- Assert&#13;
## 设计模式封装&#13;
- Builder&#13;
- Step Builder&#13;
- 模版（接口，抽象类）&#13;
- Pipeline&#13;
- 门面（facade）&#13;
## 隐藏实现细节&#13;
- mapstruct&#13;
- querydsl&#13;
- lombok&#13;
- Converter（转换器）&#13;
## 字节码增强&#13;
- [Byte Buddy - runtime code generation for the Java virtual machine](https://bytebuddy.net/#/tutorial)&#13;
## 事件驱动&#13;
- event listener&#13;
。</description><guid isPermaLink="true">https://pyae123zd.github.io/post/sao-qi-bian-cheng-ji-qiao.html</guid><pubDate>Mon, 11 Dec 2023 02:35:04 +0000</pubDate></item></channel></rss>